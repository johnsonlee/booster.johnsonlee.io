# Static Analysis

## What Can Static Analysis Do?

After a lot of practice, we have found that many problems can actually be detected before the product is released or launched. However, due to the lack of corresponding tools, many problems are hidden and brought to production until they encountered by customers. such as UI jank, crash, security issues, etc. Through static analysis, we can detect these potential issues and risks as early as possible and fix them before release, this is the original intention of the Booster project.

## Why not SonarQube?

SonarQube is a famous source code oriented analysis tools, it doesn't support analysis byte code generated by compilers, due the limitation of source code based analysis, Booster was born for bytecode oriented static analysing.

## What Problems does Booster's Static Analysis Solve?

[booster-task-analyser](https://github.com/didi/booster/tree/master/booster-task-analyser) analyse apps by generating the cal graph, and then generate a analysis report, it provides more insights to help developers improve the app quality continously, including but not limited to:

1. Detecting potential performance issues, such as: API calls that may block or slow down the main/UI thread.
1. Detecting risky API calls
1. Analysing class dependencies

## What's the Solution?

### Standalone Task

Booster's static analysis is based on an independent task but not a transformer, the reason for this design is mainly based on the following considerations:

1. The frequency of static analsysis of the application might not as frequent as build, so a task is more suitable than a transformer.
1. The *CHA (Class Hierarchy Analysis)* need to get all class information, and the transformer is based on pipeline processing, which is not suitable for static analysis.
1. The static analysis might take a long time, as a transformer, it will slow down the build process, and the app build doesn't depend on the analysis result.

The following figure shown the dependency of *Analyser Task*:

<svg width="514pt" height="188pt" viewBox="0.00 0.00 513.51 188.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 184)">
<title>analyser</title>
<polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-184 509.5063,-184 509.5063,4 -4,4"></polygon>
<!-- analyse -->
<g id="node1" class="node">
<title>analyse</title>
<polygon fill="#f18f01" stroke="transparent" points="281.4639,-180 216.9891,-180 216.9891,-144 281.4639,-144 281.4639,-180"></polygon>
<text text-anchor="middle" x="249.2265" y="-157.8" font-family="Helvetica,sans-Serif" font-size="14.00" fill="#ffffff">analyse</text>
</g>
<!-- analyseDebug -->
<g id="node2" class="node">
<title>analyseDebug</title>
<polygon fill="#006e90" stroke="transparent" points="238.2016,-108 132.2514,-108 132.2514,-72 238.2016,-72 238.2016,-108"></polygon>
<text text-anchor="middle" x="185.2265" y="-85.8" font-family="Helvetica,sans-Serif" font-size="14.00" fill="#ffffff">analyseDebug</text>
</g>
<!-- analyse&#45;&gt;analyseDebug -->
<g id="edge1" class="edge">
<title>analyse-&gt;analyseDebug</title>
<path fill="none" stroke="#555555" d="M233.0766,-143.8314C225.5548,-135.3694 216.47,-125.1489 208.2461,-115.8971"></path>
<polygon fill="#555555" stroke="#555555" points="210.8535,-113.5621 201.5938,-108.4133 205.6216,-118.2127 210.8535,-113.5621"></polygon>
</g>
<!-- analyseRelease -->
<g id="node3" class="node">
<title>analyseRelease</title>
<polygon fill="#006e90" stroke="transparent" points="404.8079,-108 289.6451,-108 289.6451,-72 404.8079,-72 404.8079,-108"></polygon>
<text text-anchor="middle" x="347.2265" y="-85.8" font-family="Helvetica,sans-Serif" font-size="14.00" fill="#ffffff">analyseRelease</text>
</g>
<!-- analyse&#45;&gt;analyseRelease -->
<g id="edge2" class="edge">
<title>analyse-&gt;analyseRelease</title>
<path fill="none" stroke="#555555" d="M273.956,-143.8314C286.1427,-134.8779 301.0088,-123.9558 314.1577,-114.2955"></path>
<polygon fill="#555555" stroke="#555555" points="316.5183,-116.9042 322.5049,-108.1628 312.3738,-111.263 316.5183,-116.9042"></polygon>
</g>
<!-- transformClassesWithXxxForDebug -->
<g id="node4" class="node">
<title>transformClassesWithXxxForDebug</title>
<polygon fill="#99c24d" stroke="transparent" points="238.6799,-36 -.2269,-36 -.2269,0 238.6799,0 238.6799,-36"></polygon>
<text text-anchor="middle" x="119.2265" y="-13.8" font-family="Helvetica,sans-Serif" font-size="14.00" fill="#ffffff">transformClassesWithXxxForDebug</text>
</g>
<!-- analyseDebug&#45;&gt;transformClassesWithXxxForDebug -->
<g id="edge3" class="edge">
<title>analyseDebug-&gt;transformClassesWithXxxForDebug</title>
<path fill="none" stroke="#555555" d="M168.5719,-71.8314C160.8151,-63.3694 151.4463,-53.1489 142.9655,-43.8971"></path>
<polygon fill="#555555" stroke="#555555" points="145.4427,-41.4198 136.1053,-36.4133 140.2826,-46.1499 145.4427,-41.4198"></polygon>
</g>
<!-- transformClassesWithXxxForRelease -->
<g id="node5" class="node">
<title>transformClassesWithXxxForRelease</title>
<polygon fill="#99c24d" stroke="transparent" points="505.2865,-36 257.1665,-36 257.1665,0 505.2865,0 505.2865,-36"></polygon>
<text text-anchor="middle" x="381.2265" y="-13.8" font-family="Helvetica,sans-Serif" font-size="14.00" fill="#ffffff">transformClassesWithXxxForRelease</text>
</g>
<!-- analyseRelease&#45;&gt;transformClassesWithXxxForRelease -->
<g id="edge4" class="edge">
<title>analyseRelease-&gt;transformClassesWithXxxForRelease</title>
<path fill="none" stroke="#555555" d="M355.8061,-71.8314C359.5623,-63.8771 364.0522,-54.369 368.2063,-45.5723"></path>
<polygon fill="#555555" stroke="#555555" points="371.4261,-46.9503 372.5313,-36.4133 365.0964,-43.9612 371.4261,-46.9503"></polygon>
</g>
</g>
</svg>

### Class Hierarchy Analysis

The CHA (Class Hierarchy Analysis) is very important for static analysis, it determines the accuracy of the analysis results.

In transform, CHA is implemented by using `ClassLoader`, which is easy and simple, about more details, please see [KlassPool](https://github.com/didi/booster/blob/master/booster-transform-spi/src/main/kotlin/com/didiglobal/booster/transform/KlassPool.kt) & [Klass](https://github.com/didi/booster/blob/master/booster-transform-spi/src/main/kotlin/com/didiglobal/booster/transform/Klass.kt), it is mainly to solve the problem of how to judge whether the two type have an inheritance relationship.

However, the [booster-task-analyser](https://github.com/didi/booster/tree/master/booster-task-analyser) is implemented by loading all classes with [ClassFileParser](https://github.com/didi/booster/blob/master/booster-cha/src/main/kotlin/com/didiglobal/booster/cha/ClassFileParser.kt).

Why there are two implementations of CHA? the main reasons are as follows:

1. When `ClassLoader` load a class, although it is not necessary to initialize the class, the `ClassLoader` will verify the bytecode and may throw a `VerifyError` which will cause the entire analysis process to fail.
1. Overhead performance —— The performance of loading class by `ClassLoader` is far from *ASM*.
1. In addition to analyzing the inheritance relationship of the classes, it's also necessary to analyze the fields, methodand annotations, and obtaining information from class by reflection has some limitation, such as runtime-invisible annotations, it's impossible to reflect they from `Class`.
1. Compared with transformer, task can be executed independently, if all classes are loaded in the process of Transform, it may cause memory constraints and even OOM.

### The Entry Points for Analysing

To analyse an application, the static analyser requires an entry point, for general programs, the `main` method is the entry point, for Android applications, the `Application`, `Activity`, `Service`, `Broadcast` and `Provider` are the entry points, so, the first thing is locating these entry points.

#### Android Components

For `Application`, `Activity`, `Service`, `Broadcast` and `Provider`, they all registered in the *AndroidManifest.xml*, it's easy to get the final *AndroidManifest.xml* through the [mergedManifests](https://github.com/didi/booster/blob/master/booster-android-gradle-api/src/main/kotlin/com/didiglobal/booster/gradle/BaseVariant.kt#L150).

#### Custom Views

The most straightforward way to list up all custom views is to parse the layout xmls, which can be obtained through the [mergeRes](https://github.com/didi/booster/blob/master/booster-android-gradle-api/src/main/kotlin/com/didiglobal/booster/gradle/BaseVariant.kt#L158), it's just an [APC format (AAPT2 Container Format)](https://github.com/aosp-mirror/platform_frameworks_base/blob/master/tools/aapt2/formats.md) file produced by the [AAPT2](https://developer.android.com/studio/command-line/aapt2) command-line tool, that's why [booster-aapt2](https://github.com/didi/booster/tree/master/booster-aapt2) comes out.

> According to the benchmark test, we have found that parsing AAPT2 container file is not as efficient as parsing the XML source file, so, the final implementation is a combination of two solutions -- parsing the AAPT container file header by AAPT2 container parser first, and then get the source XML from the file header.

#### Methods and Classes Annotated with Thread Annotations

The Android SDK already provided the [Thread Annotations](https://developer.android.com/studio/write/annotations#thread-annotations) to help the compiler and lint to improve the inspection accuracy. so, if a class or method annotated with the [Thread Annotations](https://developer.android.com/studio/write/annotations#thread-annotations), then it can be considered as an entry point.

Considering that some third-party frameworks also have their own thread annotations, such as [Event Bus](https://github.com/greenrobot/EventBus) , so the [booster-task-analyser](https://github.com/didi/booster/tree/master/booster-task-analyser) supports it by treating the method annotated with `@Subscribe(threadMode = MAIN)` as an entry point.

## Getting Started

Putting the [booster-task-analyser](https://github.com/didi/booster/tree/master/booster-task-analyser) into the classpath of Gradle build script:

<CodeGroup>
  <CodeGroupItem title="Groovy" active>

```groovy
buildscript {
    ext.booster_version = "4.11.0"

    dependencies {
        classpath "com.didiglobal.booster:booster-gradle-plugin:$booster_version"
        classpath "com.didiglobal.booster:booster-task-analyser:$booster_version"
    }
}
```

  </CodeGroupItem>
  <CodeGroupItem title="Kotlin">

```kotlin
buildscript {
    val booster_version = "4.11.0"

    dependencies {
        classpath("com.didiglobal.booster:booster-gradle-plugin:$booster_version")
        classpath("com.didiglobal.booster:booster-task-analyser:$booster_version")
    }
}
```

  </CodeGroupItem>
</CodeGroup>

Then, execute the *analyse* task by command line:

```bash
$ ./gradlew analyse
```
After the execution is successful, a dot format report will be generated in the *build/reports/* directory, the *.dot* files can be converted to *.png* format by using the dot command line tool provided by [Graphviz](https://graphviz.org/):

```bash
$ find build/reports -name '*.dot' | xargs -t -I{} dot -O -Tpng {}
```

## White/Black Lists

The white list is used for API ignoring, and the black list is used for API highlighting, Booster already provided a default [whiltelist.txt](https://github.com/didi/booster/blob/master/booster-task-analyser/src/main/resources/whitelist.txt) and [blacklist.txt](https://github.com/didi/booster/blob/master/booster-task-analyser/src/main/resources/blacklist.txt), these are came from the practical experience, it also supports customization.

### Specify white/black lists by *gradle.properties*

```properties
booster.task.analyser.whitelist=file:///Users/booster/whitelist.txt
booster.task.analyser.blacklist=file:///Users/booster/blacklist.txt
```

### Specify white/black lists by command line

```bash
$ ./gradlew assembleDebug \
    -Pbooster.task.analyser.whitelist=file:///Users/booster/whitelist.txt \
    -Pbooster.task.analyser.blacklist=file:///Users/booster/blacklist.txt
```

The white/black list also can be a remote URL, for example:

```bash
./gradlew assembleDebug \
    -Pbooster.task.analyser.whitelist=https://booster.johnsonlee.io/analyser/whitelist.txt
```

